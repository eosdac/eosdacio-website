<!DOCTYPE html>
<html lang="ru"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>
    
      eosDAC | Сообщество-производитель блоков EOS и разработчик DAC
    
  </title>
  <meta property="og:title" content="eosDAC">
  <meta property="og:site_name" content="eosDAC">
  <meta name="description" content="Сообщество-производитель блоков EOS и разработчик DAC">
  <meta property="og:description" content="Сообщество-производитель блоков EOS и разработчик DAC">
  <link rel="shortcut icon" type="image/png" href="/assets/favicon.png?1565212132">
  <link href="/assets/styles.css?1565212132s" rel="stylesheet">
  <link href="https://vjs.zencdn.net/7.4.1/video-js.css" rel="stylesheet">
  <link rel="stylesheet" href="/assets/videojs-resolution-switcher.css">
  <link rel="stylesheet"
    href="https://unpkg.com/bootstrap-material-design@4.1.1/dist/css/bootstrap-material-design.min.css"
    integrity="sha384-wXznGJNEXNG1NFsbm0ugrLFMQPWswR3lds2VeinahP8N0zJw9VWSopbjv2x7WCvX"
    crossorigin="anonymous">
  <link rel="stylesheet" href="/assets/bootstrap-material-design-overwrite.css?1565212132">
  <link rel="stylesheet"
    href="https://fonts.googleapis.com/css?family=Roboto:100,200,300,400,500,600">
  <link rel="stylesheet" href="/assets/main.css?1565212132">
  <script src="https://code.jquery.com/jquery-3.3.1.min.js"
    integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="crossorigin="anonymous"></script><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/ru/feed.xml" title="site.title" /><link rel="alternate" hreflang="en" href="https://eosdac.io">
  <link rel="alternate" hreflang="ko" href="https://eosdac.io/ko/">
  <link rel="alternate" hreflang="zh-hans" href="https://eosdac.io/zh-hans/">
  <link rel="alternate" hreflang="vi" href="https://eosdac.io/vi/">
  <link rel="alternate" hreflang="ja" href="https://eosdac.io/ja/">
  <link rel="alternate" hreflang="es" href="https://eosdac.io/es/">
  <link rel="alternate" hreflang="ru" href="https://eosdac.io/ru/">
  <link rel="canonical" href="https://eosdac.io/">
  <script src="/assets/vconsole.min.js"></script>
  <script>
    // Init vConsole, if the ?debug=true parameter exists
    if(window.location.search.substr(1).indexOf('debug=true') >= 0) {
      var vConsole = new VConsole()
    }
  </script>
</head>
<body><header class="site-header" role="banner" style="border:0">
  <nav class="navbar fixed-top navbar-expand-lg navbar-dark bg-dark nav-tabs"
    style="background-image:linear-gradient(to right, #4A1289, #7C41BA)">
    <a class="navbar-brand" href="/ru/">
      <img src="/assets/signet-white.svg" height="42" alt="eosDAC">
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse"
      data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false"
      aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarNav">
      <ul class="navbar-nav mr-auto">
        
        
        
        
        
        
        <li class="nav-item"><a class="nav-link" href="/ru/why-vote/">
            Зачем голосовать за eosDAC?</a></li>
        
        
        
        
        
        <li class="nav-item"><a class="nav-link" href="/ru/why-join/">
            Зачем присоединяться к eosDAC?</a></li>
        
        
        
        
        
        <li class="nav-item"><a class="nav-link" href="/ru/why-launch/">
            Зачем запускать DAC?</a></li>
        
        
        
        <li class="nav-item"><a class="nav-link" href="/ru/community/">
            Сообщество</a></li>
        
        
        
        
        
        <li class="nav-item"><a class="nav-link" href="/ru/token/">
            Токены</a></li>
        
        
        
        <li class="nav-item"><a class="nav-link" href="/ru/tools/">
            Инструменты</a></li>
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        <li class="nav-item"><a class="nav-link" href="/ru/news/index.html">
            Новости</a></li>
        
        
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown"
            role="button" data-toggle="dropdown" aria-haspopup="true"
            aria-expanded="false">
            <img src="/assets/flags/ru.png" />
          </a>
          <div class="dropdown-menu" aria-labelledby="navbarDropdown">
            
            
            
            
            <a class="dropdown-item" href="/tools/smart-contracts-explained/">
              <img src="/assets/flags/en.png" />&nbsp;English
            </a>
            
            
            
            
            
            
            <a class="dropdown-item" href="/ko/tools/smart-contracts-explained/">
              <img src="/assets/flags/ko.png" />&nbsp;한국어
            </a>
            
            
            
            
            
            
            <a class="dropdown-item" href="/zh-hans/tools/smart-contracts-explained/">
              <img src="/assets/flags/zh-hans.png" />&nbsp;简体中文
            </a>
            
            
            
            
            
            
            <a class="dropdown-item" href="/vi/tools/smart-contracts-explained/">
              <img src="/assets/flags/vi.png" />&nbsp;Tiếng Việt
            </a>
            
            
            
            
            
            
            <a class="dropdown-item" href="/ja/tools/smart-contracts-explained/">
              <img src="/assets/flags/ja.png" />&nbsp;日本語
            </a>
            
            
            
            
            
            
            <a class="dropdown-item" href="/es/tools/smart-contracts-explained/">
              <img src="/assets/flags/es.png" />&nbsp;Español
            </a>
            
            
            
             
          </div>
        </li>
      </ul>
      <span class="navbar-text nav-buttons">
        <a href="/ru/why-vote/#voting-matters" class="btn solid light btn-raised scatter-vote-oneclick">
          Голосуйте за eosdacserver
        </a>
        <a href="https://members.eosdac.io/" class="btn outline light btn-raised">
          Клиент Участника
        </a>
      </span>
    </div>
  </nav>
</header>
<main class="page-content main" style="padding:0;" aria-label="Content">
      <div class="">
        <div class="smart-contracts-explained">
<div class="section head dark">
  <div class="container">
    <div class="row">
      <div class="col-md-12">
        <h1 id="Объясняем-смарт-контракты-eosdac">Объясняем смарт-контракты eosDAC</h1>

      </div>
    </div>
  </div>
</div>

<div class="section">
  <div class="container">
    <div class="row">
      <div class="col-md-12">
        <h3 id="О-чём-идет-речь">О чём идет речь?</h3>
<p>На днях меня спросили о eosDAC, и что же особенного в нашей работе по созданию такой “странной” вещи, которую мы называем DAC инструменты. Чем отличается это решение от централизованных решений для управления организациями и их операциями? Насколько это безопасно? Как мы смогли разработать и построить коллекцию смарт-контрактов, гарантирующую, что ни одна другая организация не сможет навредить DAC через смарт-контракты?</p>

<p>Уже было несколько статей и постов в нашем блоге, обсуждающих основные принципы и управление DAC с помощью программного кода, в этой же статье сосредоточимся на смарт-контрактах, и как они работают для достижения безопасного автономного управления. Весь исходный код доступен для просмотра/использования/адаптации на Github, но не все же знакомы с C++.</p>

<p>Одна из главных идей во всех наших смарт-контрактах – это возможность их повторного использования другими DAC, чтобы можно было без проблем скопировать и использовать наш исходный код. С самого начала это стало для нас основным убеждением и оправданием того, почему некоторые решения стали более сложными, чем могли бы быть, если бы мы разрабатывали решение исключительно для нас. Будущая цель - сделать их еще более удобными, чтобы другие DAC могли использовать наши смарт-контракты и настраивать их параметры для своих собственных целей без необходимости переписывать исходный программный код. Таким образом, они получат все обновления одновременно вместе с командой eosDAC при добавлении новых функций и исправлении возможных ошибок.</p>

<p>Код контрактов состоит из контрактов для токенов (<code class="highlighter-rouge">eosdactokens</code>), для выборов и управления хранителями (<code class="highlighter-rouge">dacustodian</code>), для подачи и управлению рабочими предложениями, а также для оплаты и координации отдельного депозитного счета (<code class="highlighter-rouge">dacescrow</code>), чтобы надежно сохранить средства по рабочим предложениям. Это необходимо, как для защиты самого DAC, так и работника от возможной потери оплаты за выполненную работу.</p>

<h2 id="eosdactokens">EOSDACTOKENS</h2>

<p>С этого контракта всё и началось. Токены EOSDAC хранятся в этом смарт-контракте. Все началось с копирования <code class="highlighter-rouge">eosio.token</code> - главного контракта для токенов, который используется и для токена EOS, а также является отправной точкой для всех токенов, работающих на блокчейне EOS. Мы добавили некоторые функциональные возможности к этому контракту, чтобы соответствовать нашим потребностям для запуска DAC и первоначального эирдропа. Он включает в себя следующее:</p>

<h3 id="Возможность-создания-токенов-в-заблокированном-состоянии">Возможность создания токенов в заблокированном состоянии</h3>
<p>Основная цель заключалась в том, чтобы во время первоначального дропа держателям оригинальных токенов на базе Ethereum в июне 2018 года, мы бы смогли провести тщательную проверку балансов аккаунтов получателей прежде чем пользователи смогли бы начать торговать своими токенамии и убедились, что они соответствуют ожидаемым остаткам при снимке сети Ethereum. Мы очень серьезно отнеслись к тестированию :)</p>

<p>EOSDAC был одним из первых токенов, который сделал эирдроп в сети EOS, так что многое на тот момент было неизвестно. Как только дроп был завершен и протестирован, мы смогли разблокировать токены и разрешить их передачу. Важно отметить, что нет возможности повторно заблокировать токен после того, как его разблокировали, так как эта функция могла бы позволить создателям токенов манипулировать ценой посредством централизованного контроля ликвидности токенов.</p>

<h3 id="Условия-принятия-участников">Условия принятия участников</h3>
<p>Согласие с условиями использования в рамках DAC рассматривалось нами как фундаментальная ключевая особенность смарт-контрактов DAC, и поэтому имело смысл включить эту функциональность в контракт токенов. Пользователь становится зарегистрированным участником сообщества после подтверждения и выполнения действия <code class="highlighter-rouge">memberreg</code> по контракту.</p>

<p>Для выполнения этого действия пользователь должен будет согласиться с условиями, и тем самым подтвердит контрольную сумму с известной контрольной суммой последних условий, прежде чем стать зарегистрированным участником. Эта логика контрольной суммы абстрагируется от конечного пользователя через графический интерфейс, и предоставляет криптографическое подтверждение того, что пользователь согласился с определенным набором терминов и добавляет своё согласие для взаимодействия с кодом контракта. Пока выполняются эти условия и совпадает контрольная сумма известных условий действие <code class="highlighter-rouge">memberreg</code> успешно выполняется. Хотя это может показаться слишком сложным способом подтверждения согласия с терминами и условиями, мы специально выбрали такой подход, потому что это как сказать «я согласен <em>с этими</em> условиями» вместо того, чтобы спрашивать пользователя «Согласны ли вы с последними положениями и условиями» с ответом пользователя «да» или «нет». Мы считаем, что последнее будет менее надежным, так как пользователь может случайно принять неправильные условия, которые уже устарели в контракте.</p>

<p>В интересах экономии использования RAM для всех конечных пользователей в контракте хранится только ссылка на хэш принятых условий, хранящийся в контракте, а не копия принятого хэша для каждого пользователя. Это означает, что каждому пользователю нужно хранить только версию принятых терминов (8 байт), а не весь хэш (32 байта) , и поскольку использование RAM в сети дорого, любая небольшая экономия нам помогает.</p>

<p>Состояние принятия последних условий каждым участником неоднократно упоминаются в смарт-контрактах eosDAC, чтобы гарантировать, что пользователь не сможет выполнять действия в DAC без согласия с последними условиями, в том числе и в будущем при обновлении таких условий.</p>

<h2 id="daccustodian">DACCUSTODIAN</h2>

<p>Этот контракт управляет всеми ставками, выдвижением, голосованием, подсчетом голосов и назначением хранителей по завершении каждого периода выборов. Конечным результатом действий этого контракта является управление разрешениями на управляющей учетной записи DAC (<code class="highlighter-rouge">dacauthority</code>), настраиваемыми с помощью конфигураций этого контракта. Управляющая учетная запись имеет заранее определенные разрешения на все действия в DAC, включая изменение кода и перевод средств. Эти разрешенные действия управляются различными транзакциями с мультиподписью, используя встроенные сложные инструменты управления разрешениями, доступные в программном обеспечении протокола EOSIO. Параметры избирательного процесса могут быть изменены с помощью конфигурации, установленной в контракте при помощи действия <code class="highlighter-rouge">updateconfig</code>. Функциональность этого контракта можно разбить на следующие разделы:</p>

<h3 id="cтекирование">Cтекирование</h3>
<p>Перед тем, как выдвинуть себя в качестве кандидата, участник должен сначала перенести определенную сумму EOSDAC, используя действие <code class="highlighter-rouge">transfer</code> по контракту токена на этот счет. Поле Memo должно быть одинаковым с именем учетной записи этого контракта (например “daccustodian”) для того, чтобы перенос был признан как транзакция по стекингу, а требуемая сумма настраивается полем <code class="highlighter-rouge">lockupasset</code> в объекте конфигурации. После установки ставки в контракте будет указана сумма ожидающей ставки для этого кандидата, готового к выдвижению.</p>

<h3 id="Выдвижение-кандидатов---nominatecand">Выдвижение кандидатов - <code class="highlighter-rouge">nominatecand</code>:</h3>
<p>Чтобы стать избранным хранителем DAC, зарегистрированный участник должен сначала выдвинуть себя в качестве кандидата, используя действие<code class="highlighter-rouge">nominatecand</code>. Для этого потребуется указать имя выдвигаемой учетной записи и запрашиваемую сумму оплаты в EOS. Это действие проверяет, что пользователь является зарегистрированным участником и стекировал достаточное количество токенов EOSDAC. Также контракт проверяет, что запрашиваемая сумма оплаты не превышает допустимое значение <code class="highlighter-rouge">requested_pay_max</code> из конфигурации, и если все эти условия будут выполнены, добавит пользователя в качестве кандидата для голосования.</p>

<h3 id="Голосование---votecust">Голосование - <code class="highlighter-rouge">votecust</code>:</h3>
<p>Голосование осуществляется действием <code class="highlighter-rouge">votecust</code> и потребует учетную запись избирателя и наличие списка кандидатов, за которых вы хотите проголосовать. Голосование проводится по следующим правилам:</p>

<ul>
  <li>Голосование требует действительного членства и согласия с текущими условиями участия.</li>
  <li>Вес каждого голоса определяется балансом EOSDAC, который избиратель имеет на своем счете. (В настоящее время для голосования не требуется никаких ставок)</li>
  <li>После того, как голоса избирателя будут размещены, это голосование остается активным до тех пор, пока избиратель не изменит свои голоса. Если баланс аккаунта упадёт до 0, а затем снова станет положительным или один из кандидатов уходит в отставку, а затем возвращается, голосование за него по-прежнему будет активным и применимым при подсчете голосов.</li>
  <li>Все кандидаты, за которых проголосовал избиратель, получают одинаковый вес голоса на основе баланса EOSDAC.</li>
  <li>Существует максимальное количество кандидатов, за которых избиратель может голосовать, определяемое настройкой конфигурации.</li>
  <li>Чтобы удалить голосование, избирателю нужно будет проголосовать с пустым списком кандидатов.</li>
  <li>Голосование и передача токенов для голосования будет иметь прямое и непосредственное влияние на вес каждого активного голосования, но единственный раз, когда вес голосов будет иметь значение - это блок, когда вызывается действие <code class="highlighter-rouge">newperiod</code>. (Объяснено ниже)</li>
</ul>

<h3 id="Новый-период-выборов---newperiod">Новый период выборов - <code class="highlighter-rouge">newperiod</code>:</h3>
<p>Для каждого действительного кандидата вес голоса будет непрерывно отслеживаться на основе изменений, вызванных действием <code class="highlighter-rouge">votecust</code> или действием <code class="highlighter-rouge">transfer</code> в контракте токена, если есть активное голосование за учетные записи <code class="highlighter-rouge">from</code> или <code class="highlighter-rouge">to</code> в действии передачи. При непрерывном отслеживании этих значений фактические выборы (во время <code class="highlighter-rouge">newperiod</code>) должны только сделать снимок кандидатов, выбранных большинством голосов в этот момент. Количество кандидатов настраивается с помощью поля <code class="highlighter-rouge">numelected</code> в конфигурации. Для успешного выполнения действия <code class="highlighter-rouge">newperiod</code> потребуются другие проверки, в том числе:</p>

<ul>
  <li>Убедитесь, что начальное число избирателей превышает <code class="highlighter-rouge">initial_vote_quorum_percent</code> в конфигурации.</li>
  <li>Убедитесь, что на последующих выборах число избирателей превышает <code class="highlighter-rouge">vote_quorum_percent</code> в конфигурации.</li>
  <li>Убедитесь, что период времени между вызовами <code class="highlighter-rouge">newperiod</code> превышает <code class="highlighter-rouge">periodlength</code> длину периода.</li>
</ul>

<p>Если все эти проверки успешно пройдены будут выполнены следующие действия:</p>

<ul>
  <li>Оплата хранителей распределяется в соответствии со средней суммой текущих сумм <code class="highlighter-rouge">requestedpay</code> хранителей.</li>
  <li>Новые хранители выбираются на основе рейтингового веса накопленных за них голосов за следующий период.</li>
  <li>Разрешения на управление учетными записями DAC обновляются для включения вновь назначенных хранителей.</li>
  <li>Текущее время сохраняется для использования в качестве временной ссылки для будущих вызовов <code class="highlighter-rouge">newperiod</code>, чтобы убедиться, что он не вызывается слишком рано для следующего периода.</li>
  <li>Для каждого кандидата, избранного в качестве хранителя, будут заблокированы их токены, чтобы показать, что они достаточно благонадежны. Они смогут отменить блокировку токенов, как только они больше не будут хранителями в течении, определенного <code class="highlighter-rouge">lockup_release_time_delay</code> времени из конфигурации.</li>
</ul>

<h3 id="Другие-операции">Другие операции:</h3>
<p>В дополнение ко всему вышеперечисленному, есть и другие действия, поддерживаемые в этом контракте, включая:</p>

<ul>
  <li>Снять кандидата (<code class="highlighter-rouge">withdrawcand</code>): Эта функция вызывается существующим кандидатом, в том числе тем, который в настоящее время является избранным хранителем, если он захочет снять себя со следующего периода выборов. Его токены будут остануться заблокированными до истечения заданного промежутка времени. Хороший пример использования этой функции – это возможный отпуск хранителя, но вскоре он собирается вернуться (вот почему функция разблокировки токенов существует отдельно от этой). В противном случае это действие могло бы быть использовано по любой другой причине для добровольного отказа кандидата от участия в деятельности DAC.</li>
  <li>Уволить кандидата (<code class="highlighter-rouge">firecand</code>): Это действие в настоящее время может быть вызвано только избранными хранителями с помощью мультиподписи, чтобы удалить кандидата с плохой репутацией или поведением. Это действие также имеет возможность заблокировать токены кандидата, если они еще не заблокированы.</li>
  <li>Уволить хранителя (<code class="highlighter-rouge">firecust</code>): Аналогично с <code class="highlighter-rouge">firecand</code> это действие приведет к отстранению от должности в настоящее время избранного хранителя по решению других хранителей. Это приведет к удалению хранителя из избранной группы хранителей, а также удалит его в качестве потенциального кандидата на будущие выборы, заменит хранителя следующим в списке по количеству голосов кандидатом и, наконец, обновит разрешения учетной записи, чтобы отразить новый набор избранных хранителей.</li>
  <li>Отправить хранителя в отставку (<code class="highlighter-rouge">resigncust</code>): Это действие выполняется активным хранителем, который хотел бы уйти с должности действующего хранителя. Это отменит его регистрацию в качестве кандидата и заменит хранителя следующим в списке по количеству голосов кандидатом.</li>
  <li>Обновление запрашиваемой оплаты (<code class="highlighter-rouge">updatereqpay</code>): Кандидат может обновить свою запрошенную оплату за работу качестве хранителя. Но обновление не вступит в силу до следующего периода, чтобы предотвратить изменение средней дельты в текущем периоде.</li>
  <li>Запросить оплату (<code class="highlighter-rouge">claimpay</code>): Это действие, вызывается активным хранителем, чтобы получить сумму оплаты, которая должна быть ему выплачена. Из-за особенностей правовой системы и другим юридическим причинам этот платеж проводится через сервисную компанию. С точки зрения контракта - это действие по оплате услуг хранителю DAC, и после этого данное обязательство считается выполненным.</li>
  <li>
    <p>Обновление конфигурации (<code class="highlighter-rouge">updateconfig</code>): Существует несколько настраиваемых параметров контракта, позволяющих его использование без необходимости перекомпиляции всего кода. Основная идея заключается в том, что это позволит другим DAC работать с одним и тем же развернутым кодом, но со своими собственными конфигурациями. Изменения вносятся путем установки нового объекта в конфигурации с помощью действия со следующими параметрами:</p>

    <ul>
      <li><code class="highlighter-rouge">lockupasset</code>: Сумма токенов EOSDAC, которые необходимо стекировать каждому кандидату, участвующему в выборах.</li>
      <li><code class="highlighter-rouge">maxvotes</code> : Максимальное количество кандидатов, за которых каждый участник может проголосовать. (По умолчанию 5)</li>
      <li><code class="highlighter-rouge">numelected</code> : Число хранителей, избираемых при каждом подсчете голосов.</li>
      <li><code class="highlighter-rouge">periodlength</code> : Продолжительность периода в секундах. Используется для предотвращения досрочных выборов от вызова функции <code class="highlighter-rouge">newperiod</code>. (По умолчанию 7 дней)</li>
      <li><code class="highlighter-rouge">authaccount</code> : Контрольная учетная запись должна иметь разрешения, установленные избранными хранителями.</li>
      <li><code class="highlighter-rouge">tokenholder</code> : Контракт, в котором хранятся средства DAC. Используется в качестве источника для оплаты хранителям.</li>
      <li><code class="highlighter-rouge">serviceprovider</code> : Контракт, который будет выступать в качестве учетной записи поставщика услуг для DAC. Используется в качестве источника для оплаты хранителям и участникам по рабочим предложениям.</li>
      <li><code class="highlighter-rouge">should_pay_via_service_provider</code> : Если установлено значение true, контракт будет направлять все платежи через поставщика услуг, а не напрямую.</li>
      <li><code class="highlighter-rouge">initial_vote_quorum_percent</code> : Необходимое количество проголосовавших токенов, необходимых для запуска совета хранителей.</li>
      <li><code class="highlighter-rouge">vote_quorum_percent</code> : Необходимое количество проголосовавших токенов, необходимых для запуска нового совета хранителей после достижения первоначального порога - 2ой период выборов и далее.</li>
    </ul>

    <p>Необходимое количество хранителей для утверждения различных уровней аутентифицированных действий в смарт-контрактах DAC:</p>

    <ul>
      <li><code class="highlighter-rouge">auth_threshold_high</code></li>
      <li><code class="highlighter-rouge">auth_threshold_mid</code></li>
      <li><code class="highlighter-rouge">auth_threshold_low</code></li>
      <li><code class="highlighter-rouge">lockup_release_time_delay</code> : Время до того, как заблокированные токены будут возвращены кандидату с помощью действия unstack.</li>
      <li><code class="highlighter-rouge">requested_pay_max</code> : Максимальная сумма оплаты, которую может запросить хранитель.</li>
    </ul>
  </li>
</ul>

<h2 id="dacproposals">DACPROPOSALS</h2>

<p>Этот контракт отвечает за управление рабочими предложениями DAC. Он снова построен с учетом максимальной конфигурируемости, а не только для решения задач eosDAC.</p>

<p>Общая идея заключается в том, что у потенциального работника есть идея для реализации, которую он хотел бы предложить DAC в обмен на оплату в токенах EOS. Для утверждения предложения проголосуют текущие хранителями, а после выполнения работы будет произведена выплата автору предложения.</p>

<h3 id="Создать-предложение-createprop">Создать предложение <code class="highlighter-rouge">createprop</code></h3>
<p>Потенциальный работник создаёт рабочее предложение и отправляет его в блокчейн для рассмотрения и голосования текущими хранителями DAC. Предложение должно включать следующее:</p>

<ul>
  <li><code class="highlighter-rouge">title</code> (String): Определение предложения.</li>
  <li><code class="highlighter-rouge">summary</code> (String): Краткое изложение цели предложения работника.</li>
  <li><code class="highlighter-rouge">arbitrator</code> (имя аккаунта EOS): Имя аккаунта независимого арбитра, который может быть вызван для решения возможных споров при завершении предложения работника.</li>
  <li><code class="highlighter-rouge">pay_amount</code> (EOSAsset): Сумма токенов EOS, запрошенная в качестве суммы оплаты для предложения работника.</li>
  <li><code class="highlighter-rouge">content_hash</code> (ChecksumHash): Хэш содержимого для обеспечения детализации предложения, хранящийся вне блокчейна, остается неизменным после согласования предложения. Это позволяет сохранить более подробную информацию, которая не будет храниться в бокчейне при сохранении целостности данных.</li>
</ul>

<p>Для каждого предложения только минимальные данные контента должны храниться в контракте, и для обеспечения целостности данных передаются через журналы транзакций. Только данные аккаунта и оплаты хранятся для использования в последующих действиях в рамках текущего контракта.</p>

<h3 id="Голосование-за-предложение-voteprop">Голосование за предложение <code class="highlighter-rouge">voteprop</code></h3>
<p>После того, как предложение было создано, оно будет находиться в состоянии, ожидающем, пока хранители проголосуют либо ‘proposal_approve’ (принято), либо ‘proposal_deny’ (отклонено) за предложение с требуемым количеством голосов и количеством голосов за ‘yes’, которые настраиваются в контракте. Также возможны уточнения к предложению с его отменой <code class="highlighter-rouge">cancel</code> и повторной подачей с изменениями на основе обратной связи от хранителей до тех пор, пока предложение не будет принято.</p>

<h3 id="Начать-работу-над-принятым-предложением-startwork">Начать работу над принятым предложением <code class="highlighter-rouge">startwork</code></h3>
<p>Если предложение было принято, работник сможет вызвать это действие, чтобы подтвердить, что он согласен начать выполнять поданную заявку с согласованными условиями оплаты и т. д. На этом этапе согласованная сумма платежа переводится на депозитный счет, чтобы гарантировать, что средства могут и будут выплачены работнику после завершения работы, одобренной хранителями или согласованную арбитром предложения.</p>

<p>Блокировка средств на счете является важным шагом для защиты работника от потенциально злонамеренных действий хранителей, которые могут отменить раннее принятое предложение. Также существует доверенный арбитр по предложению, который сможет разморозить средства.</p>

<h3 id="Сигнал-завершения-работы-completework">Сигнал завершения работы <code class="highlighter-rouge">completework</code></h3>
<p>После того, как работник завершил свою работу, он сигнализирует хранителям, что работа считается завершенной, а хранители должны будут оценить работу перед оплатой с помощью голосования, используя <code class="highlighter-rouge">voteprop</code>, но на этот раз с другими параметрами, указывая <code class="highlighter-rouge">claim_approve</code> или <code class="highlighter-rouge">claim_deny</code>.</p>

<h3 id="Требование-оплаты-за-выполненную-работу-claim">Требование оплаты за выполненную работу <code class="highlighter-rouge">claim</code></h3>
<p>Если требование с учетом текущей конфигурации набрало достаточное количество голосов от хранителей после завершения работы, то работник может вызвать действие, которое отправит платеж работнику. На данный момент в eosDAC средства отправляются на счет сервисной компании, но фактически они выплачиваются напрямую работнику за его услуги.</p>

<h3 id="Конфигурация-контракта-updateconfig">Конфигурация контракта <code class="highlighter-rouge">updateconfig</code></h3>
<p>Различные параметры настраиваются для этого контракта и включают:</p>

<ul>
  <li><code class="highlighter-rouge">service_account</code> : Имя аккаунта EOS</li>
  <li><code class="highlighter-rouge">proposal_threshold</code> : Количество голосов, необходимых для участия в голосовании за предложение.</li>
  <li><code class="highlighter-rouge">proposal_approval_threshold_percent</code> : Требуемое количество голосов для утверждения предложения.</li>
  <li><code class="highlighter-rouge">claim_threshold</code> : Количество голосов, необходимых для принятия требования по предложению.</li>
  <li><code class="highlighter-rouge">claim_approval_threshold_percent</code> : Требуемое количество голосов для принятия требования по предложению.</li>
  <li><code class="highlighter-rouge">escrow_expiry</code> : время истечения, установленное для созданной транзакции (количество секунд). Значение по умолчанию - 30 дней.</li>
</ul>

<h2 id="dacescrow">DACESCROW</h2>
<p>Этот контракт отвечает за сохранение обеспеченных средств для рабочих предложений, пока избранные хранители или согласованный арбитр не разморозит эти средства для получателя или срок депонирования истечёт, что позволит вернуть средства отправителю. Блокировка средств на счете является важным шагом для защиты работника от потенциально злонамеренных действий хранителей, которые могут отменить раннее принятое предложение. Это достигается путем удаления владельца и активных ключей аккаунта после того, как код контракта был установлен. Это еще одна причина почему контракт должен быть прозрачен и отделен от других контрактов. Будем надеяться, что этот код никогда не нужно будет изменять. Если при неудачном и маловероятном сценарии этот код необходимо будет изменить, то хранителям потребуется получить согласие от текущих производителей блоков для сброса ключа владельца для этой учетной записи.</p>

<h3 id="Инициализация-сделки-депонирования---init">Инициализация сделки депонирования - <code class="highlighter-rouge">init</code></h3>
<p>Транзакция условного депонирования может быть инициализирована только при указании всех необходимых полей, включая отправителя, предполагаемого получателя, времени истечения срока действия, арбитра, памятку для возможного действия передачи. Существует также дополнительный внешний ключ, который можно использовать в качестве ключа-ссылки для кросс-контракта, а не только полагаться на внутренний автоинкрементный ключ, который в противном случае со временем приведет к коллизиям ключей.</p>

<h3 id="Перевод-средств-на-депозит---transfer">Перевод средств на депозит - <code class="highlighter-rouge">transfer</code></h3>
<p>Средства для условного депонирования переводятся на контракт условного депонирования с использованием обычного действия <code class="highlighter-rouge">transfer</code> (перевод), он работает точно также для большинства других контрактов токенов EOS. Код этого контракта основан на встроенных уведомлениях, которые действие передачи направляет как отправителю, так и получателю счетов передачи. Когда уведомление о передаче получено контрактом депонирования, реализация функции <code class="highlighter-rouge">transfer</code> проверит, что отправитель имеет пустую запись депонирования и назначает сумму, переданную в эту запись для последующей обработки другими действиями в коде контракта. Инициализированная запись депонирования может быть отменена действием <code class="highlighter-rouge">cancel</code> (отмена) при условии, что она вызывается до того, как применили действие.</p>

<h3 id="Одобрение-или-неодобрение-сделки---approve-и-unapprove">Одобрение или неодобрение сделки - <code class="highlighter-rouge">approve</code> и <code class="highlighter-rouge">unapprove</code></h3>
<p>После того, как депонирование было инициализировано и заполнено действием передачи, следующим шагом будет утверждение депонирования отправителем, назначенным арбитром или получателем. Требуются два подтверждения от любого из этих трех аккаунтов, чтобы можно было выполнить действие <code class="highlighter-rouge">claim</code> (запросить). Действие <code class="highlighter-rouge">unapprove</code> (неодобрение) может быть впоследствии вызвано для удаления существующего утверждения соответствующим аккаунтом.</p>

<h3 id="Требование-утвержденного-депозитного-платежа---claim">Требование утвержденного депозитного платежа - <code class="highlighter-rouge">claim</code></h3>
<p>Действие требования может быть выполнено только предполагаемым получателем для оплаты условного депонирования и будет успешным только при правильном состоянии утверждения для записи условного депонирования. На этом этапе депонированная сумма будет переведена на счет назначенной сервисной компании, чтобы платежи были отправлены предполагаемому получателю.</p>

<p><em>Заметка: Шаг сервисной компании не включен по техническим причинам, но является юридическим требованием при взаимодействии с традиционным правовым миром. Мы бы хотели выполнять все действия на блокчейне в криптографически защищенной среде смарт-контрактов, но пока мир к этому не готов :( .</em></p>

<h3 id="Возврат-после-истечения-срока-действия---refund">Возврат после истечения срока действия - <code class="highlighter-rouge">refund</code></h3>
<p>Средства на депозитном счете должны быть заблокированы на определенный срок, но они также должны быть и разблокированы после истечения срока действия, если не было одобрения от отправителя или арбитра, иначе бы средства на счете были бы заблокированы навсегда. Действие <code class="highlighter-rouge">refund</code> обеспечивает этот механизм и может быть вызвано только отправителем, если уже прошло время истечения срока действия. Затем депонированная сумма будет возвращена отправителю, а запись депонирования будет удалена, чтобы предотвратить сценарий возможного двойного возврата.</p>

<p><a href="/ru/tools/">Назад</a></p>

      </div>
    </div>
  </div>
  <div style="background-image:url(/assets/footer-bkgr.png);background-repeat:no-repeat;background-size:100% auto;margin-top:50px;">
    <img src="/assets/spacer.gif" style="width:100%;"/>
</div>
</div>
</div>
      </div>
    </main><footer class="site-footer h-card" style="border:0;padding:0;">
  <div class="footer">

    <div class="container">
      <div class="row">
        <div class="col-md-3">
          <h2 id="Важные-ссылки">Важные ссылки</h2>
<p><a href="/ru/why-vote/#core-principles">Кодекс поведения</a><br />
<a href="/ru/history/">История eosDAC</a><br />
<a href="https://eosdac.zendesk.com/">Центр Поддержки</a><br />
<a href="/styleguide">Дизайн</a><br />
<a href="https://steemit.com/eos/@shadow82/zayavlenie-o-cobstvennosti-i-kodeks-povedeniya">Раскрытие информации</a><br />
<a href="/bp.json">Информация о БП</a></p>

        </div>
        <div class="col-md-6">
          <h2 id="Новостная-рассылка">Новостная рассылка</h2>

          <form id="newsletterForm">
    <div class="row">
        <div class="col-md-6">
            <div class="form-group">
                <label for="name" class="bmd-label-floating">
                    Имя
                </label>
                <input type="text" class="form-control" id="name" name="name">
            </div>
        </div>
        <div class="col-md-6">
            <div class="form-group">
                <label for="email" class="bmd-label-floating">
                    Почта *
                </label>
                <input type="email" class="form-control" id="email" name="email"
                    required>
            </div>
        </div>
    </div>
    <div class="row">
        <div class="col-md-6">
            <select class="form-control" id="language" name="language" required>
                <option value="">Язык *</option>
                <option value="English">&nbsp;&nbsp;&nbsp;&nbsp;English</option>
                <option value="Russian">&nbsp;&nbsp;&nbsp;&nbsp;Pусский</option>
                <option value="Korean">&nbsp;&nbsp;&nbsp;&nbsp;한국어</option>
                <option value="Chinese">&nbsp;&nbsp;&nbsp;&nbsp;简体中文</option>
            </select>
        </div>
        <div class="col-md-6">
            <button type="submit" id="submitButton" class="btn">
                Подписаться
            </button>
        </div>
    </div>
</form>
<script>
$('#newsletterForm').submit(function(event) {
    event.preventDefault();
    $.post('https://toolkit-api.eosdac.io/subscribe', $(this).serialize())
    .done( function(result) {
        if(result && (result.message === 'subscribed_successfully' || result.message === 'already_subscribed')) {
            alert('Спасибо, ваши данные обновлены!');
            document.getElementById('newsletterForm').reset();
        } else {
            alert('Ошибка:\n'+JSON.stringify(result));
        }
    })
    .fail( function(xhr, textStatus, errorThrown) {
        alert('Ошибка '+xhr.status+':\n'+xhr.responseText);
    });
});
</script>
        </div>
        <div class="col-md-3">
          <h2 id="Социальные-сети">Социальные сети</h2>
<p><a href="https://discord.io/eosdac"><i class="icon icon-social-discord-com"></i></a>
<a href="https://github.com/eosdac"><i class="icon icon-social-github-com"></i></a>
<a href="https://steemit.com/@eosdac"><i class="icon icon-social-steemit-com"></i></a>
<a href="https://twitter.com/eosdac"><i class="icon icon-social-twitter-com"></i></a>
<a href="https://www.instagram.com/eosdac"><i class="icon icon-social-instagram-com"></i></a>
<br />
<a href="https://facebook.com/eosdac"><i class="icon icon-social-facebook-com"></i></a>
<a href="https://www.reddit.com/r/eosdac"><i class="icon icon-social-reddit-com"></i></a>
<a href="https://vk.com/eosdac"><i class="icon icon-social-vk-com"></i></a>
<a href="https://www.linkedin.com/company/eosdac/"><i class="icon icon-social-linkedin-com"></i></a>
<a href="https://www.youtube.com/eosdac"><i class="icon icon-social-youtube-com"></i></a>
<br />
<a href="https://murmurdapp.com/userpost/eosdacmurmur"><i class="icon icon-social-murmur"></i></a>
<a href="https://t.me/eosdac_russian"><i class="icon icon-social-telegram"></i></a></p>

        </div>
      </div>
    </div>

    <div class="container">
      <hr style="padding: 10px 0; border-color: #BABDBE;" /><div class="row">
        <div class="col-md-2">
          <img src="/assets/signet-white.svg" height="50" alt="site.title">
        </div>
        <div class="col-md-10">
          
          
          
          
          <a class="nav-link" href="/ru/why-vote/"
            style="text-transform: none; display: inline-block; margin-top: 5px;
            color: white;">Зачем голосовать за eosDAC?</a>
          
          
          <a class="nav-link" href="/ru/why-join/"
            style="text-transform: none; display: inline-block; margin-top: 5px;
            color: white;">Зачем присоединяться к eosDAC?</a>
          
          
          <a class="nav-link" href="/ru/why-launch/"
            style="text-transform: none; display: inline-block; margin-top: 5px;
            color: white;">Зачем запускать DAC?</a>
          
          <a class="nav-link" href="/ru/community/"
            style="text-transform: none; display: inline-block; margin-top: 5px;
            color: white;">Сообщество</a>
          
          
          <a class="nav-link" href="/ru/token/"
            style="text-transform: none; display: inline-block; margin-top: 5px;
            color: white;">Токены</a>
          
          <a class="nav-link" href="/ru/tools/"
            style="text-transform: none; display: inline-block; margin-top: 5px;
            color: white;">Инструменты</a>
          
          
          
          
          
          
          
          
          
          
          
          <a class="nav-link" href="/ru/news/index.html"
            style="text-transform: none; display: inline-block; margin-top: 5px;
            color: white;">Новости</a></div>
      </div></div>
  </div>
</footer>
<script src="https://vjs.zencdn.net/7.4.1/video.js"></script>
<script src="/assets/videojs-resolution-switcher.js"></script>
<script src="https://unpkg.com/popper.js@1.12.6/dist/umd/popper.js"
  integrity="sha384-fA23ZRQ3G/J53mElWqVJEGJzU0sTs+SvzG8fXVWP+kJQ1lwFAOkcUOysnlKJC33U"
  crossorigin="anonymous"></script>
<script
  src="https://unpkg.com/bootstrap-material-design@4.1.1/dist/js/bootstrap-material-design.js"
  integrity="sha384-CauSuKpEqAFajSpkdjv3z9t8E7RlpJ1UP0lKM/+NdtSarroVKu069AlsRPKkFBz9"
  crossorigin="anonymous"></script>
<script>
$(document).ready(function() {
  $('body').bootstrapMaterialDesign()
  //initialize video players on why-join page
  videojs('why-join-video-1', null, function() {
    var player = this
    window.player = player
    player.on('fullscreenchange', function() {
      if(player.isFullscreen()) {
        label='SD'
        if(screen.width>1280) label='HD'
        player.currentResolution(label)
      } else
        player.currentResolution('SD')
    })
  }).videoJsResolutionSwitcher()
  videojs('why-join-video-2', null, function() {
    var player = this
    window.player = player
    player.on('fullscreenchange', function() {
      if(player.isFullscreen()) {
        label='SD'
        if(screen.width>1280) label='HD'
        player.currentResolution(label)
      } else
        player.currentResolution('SD')
    })
  }).videoJsResolutionSwitcher()
  videojs('why-join-video-3', null, function() {
    var player = this
    window.player = player
    player.on('fullscreenchange', function() {
      if(player.isFullscreen()) {
        label='SD'
        if(screen.width>1280) label='HD'
        player.currentResolution(label)
      } else
        player.currentResolution('SD')
    })
  }).videoJsResolutionSwitcher()
})
</script>
<!-- Voting Modal -->
<div class="modal fade" id="votingModal" tabindex="-1" role="dialog" aria-labelledby="votingModalLabel" aria-hidden="true">
<div class="modal-dialog" role="document">
    <div class="modal-content">
    <form id="votingForm">
    <div class="modal-header">
        <h5 class="modal-title" id="votingModalLabel">Вы уже выбрали 30 БП</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
        <span aria-hidden="true">&times;</span>
        </button>
    </div>
    <div class="modal-body">
            Освободите одно место, чтобы проголосовать за <code class="highlighter-rouge">eosdacserver</code>
        <br/><br/>
        <div class="container-fluid">
            <div class="row">
                <div class="col-6" style="padding:0;padding-right:10px;" id="voting_col1">
                    <!-- Will be filled via Javascript -->
                </div>
                <div class="col-6" style="padding:0;"  id="voting_col2">
                    <!-- Will be filled via Javascript -->
                </div>
            </div>
        </div>
    </div>
    <div class="modal-footer">
        <div style="padding: 0 16px;">
            <button type="button" class="btn btn-secondary" data-dismiss="modal">Отмена</button>
            <button type="submit" class="btn solid dark btn-raised">Проголосуйте</button>
        </div>
    </div>
    </form>
    </div>
</div>
</div>

<script src="/assets/eosjs/eosjs-api.js?1565212132"></script>
<script src="/assets/eosjs/eosjs-jsonrpc.js?1565212132"></script>
<script src="https://cdn.scattercdn.com/file/scatter-cdn/js/latest/scatterjs-core.min.js?1565212132"></script>
<script src="https://cdn.scattercdn.com/file/scatter-cdn/js/latest/scatterjs-plugin-eosjs2.min.js?1565212132"></script>
<script src="https://cdn.scattercdn.com/file/scatter-cdn/js/latest/scatterjs-plugin-lynx.min.js?1565212132"></script>
<script type="text/javascript">
// This file needs to be included via the LIQUID template engine, in order to make the translations work!

// Here is how to calculate the vote decay
// https://github.com/eosdac/eosdactoolkit/blob/master/eosdac-material/src/components/vote-eosdac.vue#L126
// https://github.com/eosdac/eosdactoolkit/blob/master/eosdac-material/src/components/vote-eosdac.vue#L169

const host = 'public.eosinfra.io' //TODO: use eu.eosdac.io instead? -> CORS problem
const network = {
    blockchain:'eos',
    protocol:'https',
    host,
    port:443,
    chainId:'aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906'
}
const EOSDACSERVER = 'eosdacserver'

function castVote(api, account, producers, proxy = "") {
    const transaction = {
        actions: [{
            account: 'eosio',
            name: 'voteproducer',
            authorization: [{ actor: account.name, permission: account.authority, }],
            data: { producers: producers.sort(), proxy, voter: account.name }
        }]
    }
    return api.transact(transaction, { blocksBehind: 3, expireSeconds: 30 })
}

function errHandler(scatter, target, originalContent, err, showAlert = true) {
    console.error('Voting error:', err)
    target.textContent = originalContent
    scatter.logout()

    // Do not show an alert() if the user rejected the transaction on purpose
    const rejected = ['signature_rejected', 'identity_rejected', 'Request Canceled']
    if(err &&  (rejected.includes(err.type) || rejected.includes(err.message))) {
        showAlert = false
    }
    if(showAlert) alert('Ошибка: ' + JSON.stringify(err))
}

function succHandler(scatter, target, msg = 'Спасибо за голосование!') {
    target.textContent = msg
    scatter.logout() //all done, goodbye!
}

function oneClickVote(scatter, target, originalContent) {
    target.textContent = 'Scatter голосование ...'

    const rpc = new eosjs_jsonrpc.JsonRpc('https://'+host)
    const api = new eosjs_api.Api({ rpc, signatureProvider:scatter.eosHook(network, null, true) })

    scatter.login({ accounts: [network] }).then(function() {
        const account = scatter.identity.accounts.find(x => x.blockchain === 'eos')
        /*
        We could also use get_table_rows() to get the voter_info,
        but need to make sure that the result is for 'account.name'.
        get_table_rows({
            json: true,
            code: 'eosio',
            scope: 'eosio',
            table: 'voters',
            lower_bound: account.name,
            limit: 1
        })
        */
        api.rpc.get_account(account.name).then(function(data) {
            const vote = data.voter_info
            let proxy = ''
            let producers = []
            // If vote (e.g. account.voter_info) is 'null', the eosio.voters table is empty for this account,
            // i.e. the account never voted before: Just vote for ['eosdacserver'] in this case!
            if(vote !== null) {
                proxy = vote.proxy
                producers = vote.producers
            }
            if(proxy !== '') {
                api.rpc.get_account(proxy).then(function(data) {
                    if(data && data.voter_info && data.voter_info.is_proxy === 1) {
                        const proxy_producers = data.voter_info.producers
                        const eosdacserverVoted = proxy_producers.some(function(bpName) { return bpName === EOSDACSERVER })
                        if(eosdacserverVoted === true) {
                            // Re-cast vote for the current proxy
                            castVote(api, account, [], proxy).then(function(result) {
                                succHandler(scatter, target, 'Выбранный прокси: ' + proxy)
                            }).catch(function(err) {
                                errHandler(scatter, target, originalContent, err)
                            })
                        } else {
                            // Re-cast vote for the current proxy, but notify user that it does not support eosdacserver
                            castVote(api, account, [], proxy).then(function(result) {
                                succHandler(scatter, target, 'Выбранный прокси: ' + proxy)
                                alert(proxy + ' не поддерживает eosDAC. Пожалуйста, рассмотрите другой прокси!')
                            }).catch(function(err) {
                                errHandler(scatter, target, originalContent, err)
                            })
                        }
                    } else {
                        errHandler(scatter, target, originalContent, proxy+" isn't a proxy anymore")
                        alert(proxy + ' это больше не прокси. Пожалуйста, выберите другой прокси!')
                    }
                }).catch(function(err) {
                    errHandler(scatter, target, originalContent, err)
                })
            } else {
                // Check status of all selected producers, e.g. if they are still registered
                Promise.all(producers.map(p => api.rpc.get_producers(true, p, 1))).then(function(responses) {
                    const reg_producers = responses.map(r => r.rows[0].owner)
                    let new_producers = []
                    // Add all selected AND registered producers into the new_producers array
                    producers.forEach(p => {
                        if(reg_producers.some(rp => rp === p)) new_producers.push(p)
                    })
                    producers = new_producers
                    const eosdacserverVoted = producers.some(function(bpName) { return bpName === EOSDACSERVER })
                    if(eosdacserverVoted === true) {
                        // Re-cast vote for current set of producers (including eosdacserver)
                        castVote(api, account, producers).then(function(result) {
                            succHandler(scatter, target)
                        }).catch(function(err) {
                            errHandler(scatter, target, originalContent, err)
                        })
                    } else {
                        if(producers.length < 30) {
                            // Add 'eosdacserver' to producers list and cast a vote
                            producers.push(EOSDACSERVER)
                            castVote(api, account, producers).then(function(result) {
                                succHandler(scatter, target)
                            }).catch(function(err) {
                                errHandler(scatter, target, originalContent, err)
                            })
                        } else {
                            // Show a modal dialog, to let the user remove one existing producer
                            // Set values inside the modal dialog
                            $('#voting_col1').empty()
                            $('#voting_col2').empty()
                            producers.sort().forEach(function(bpName, idx) {
                                const itm = '<div class="custom-control custom-checkbox"><input type="checkbox" class="custom-control-input" name="bp'+idx+'" id="bp'+idx+'" value="'+bpName+'" checked><label class="custom-control-label" style="font-family:monospace;" for="bp'+idx+'">'+bpName+'</label></div>'
                                if(idx < 15) {
                                    $(itm).appendTo('#voting_col1')
                                } else {
                                    $(itm).appendTo('#voting_col2')
                                }
                            })
                            // Register the submit callback, using local variables
                            $('#votingForm').submit(function(ev) {
                                ev.preventDefault()
                                const producers = $("#votingForm").serializeArray().map(function(elem) {
                                    return elem.value
                                })
                                // Add 'eosdacserver' to producers, if user removed one other producer
                                if(producers.length < 30) {
                                    producers.push(EOSDACSERVER)
                                }
                                castVote(api, account, producers).then(function(result) {
                                    $('#votingModal').modal('hide')
                                    succHandler(scatter, target)
                                }).catch(function(err) {
                                    $('#votingModal').modal('hide')
                                    errHandler(scatter, target, originalContent, err)
                                })
                            })
                            // Register the modal's Cancel/Hide handler, using local variables
                            $('#votingModal').on('hide.bs.modal', function (e) {
                                errHandler(scatter, target, originalContent, 'Modal cancelled/hidden.')
                            })
                            // Show the voting modal
                            $('#votingModal').modal('show')
                        }
                    }
                }).catch(function(err) {
                    errHandler(scatter, target, originalContent, err)
                })
            }
        }).catch(function(err) {
            errHandler(scatter, target, originalContent, err)
        })
    }).catch(function(err) {
        errHandler({ logout: function() { /* Scatter not signed in */ }}, target, originalContent, err)
    })
}

function adoptAuthenticatorByUseragent(idx, obj) {
    const originalContent = obj.textContent
    if(originalContent.includes('Scatter')) {
        const UA = window.navigator.userAgent
        // Detect EOS Lynx according to: https://developers.eoslynx.com/mobile
        if(UA === 'EOSLynx IOS' || UA === 'EOSLynx Android') {
            obj.textContent = originalContent.replace('Scatter', 'EOS Lynx')
            console.info('Adopted for EOSLynx.')
        }
    }
}

$(document).ready(function() {
    ScatterJS.plugins( new ScatterEOS(), new ScatterLynx({ Api: eosjs_api.Api, JsonRpc: eosjs_jsonrpc.JsonRpc }) )
    ScatterJS.scatter.connect('eosDAC.io').then(function( connected ) {
        if(!connected) {
            console.error('Scatter could not be found.')
            return false
        }

        // Scatter was successfully connected
        const scatter = ScatterJS.scatter
        //window.ScatterJS = null
        console.info('Scatter connected.')

        // Setup the click handler for '.scatter-vote-oneclick' links
        // and prevent their default (fallback) link/button behaviour,
        // i.e. do not follow their 'href'
        $('.scatter-vote-oneclick').click(function(ev) {
            ev.preventDefault()
            const target = ev.target
            const originalContent = target.textContent
            oneClickVote(scatter, target, originalContent)
        })
        console.info('Scatter handler registered.')

        // Adopt 'Vote using Scatter' button to 'Vote using EOS Lynx' if applicable
        $('.scatter-vote-oneclick').each(adoptAuthenticatorByUseragent)
    })
})
</script>
</body>

</html>
